package mysql

import (
	"database/sql"
	"errors"
	"fmt"
	"math/big"
	"reflect"

	"github.com/jmoiron/sqlx"
	"github.com/jmoiron/sqlx/reflectx"
	"github.com/rs/zerolog"
	"github.com/seambiz/seambiz/sdb"
)

// GENERATED BY CODEGEN.

// nolint[structcheck]
type Store struct {
	db           Execer
	withJoin     bool
	selectCalled bool
	joinType     string
	where        string
	orderBy      string
	groupBy      string
	prependField string
	limit        int
	offset       int
	batch        int
	colSet       *big.Int
	stmt         *sdb.SQLStatement
	log          *zerolog.Logger
}

// NewStore return DAO Store
func NewStore(conn Execer, logger *zerolog.Logger) *Store {
	s := &Store{}
	s.db = conn
	s.stmt = sdb.NewSQLStatement()
	s.log = logger

	return s
}

func (s *Store) SQL(stmt ...string) *Store {
	if s.stmt == nil {
		s.stmt = sdb.NewSQLStatement()
	}
	s.stmt.AppendStr(stmt...)
	return s
}

// QueryxInto uses sqlx.Select for raw SQL querying. Mapping uses tag (db) or field name.
func (s *Store) QueryxInto(dest interface{}, args ...interface{}) error {
	dbx := sqlx.NewDb(s.db.(*sql.DB), "mysql")
	s.log.Trace().Str("fn", "Store.QueryInto").Str("stmt", s.stmt.String()).Interface("args", args).Msg("sql")
	return dbx.Select(dest, s.stmt.Query(), args...)
}

// OnexInto uses sqlx.Get for raw SQL querying. Mapping uses tag (db) or field name.
func (s *Store) OnexInto(dest interface{}, args ...interface{}) error {
	dbx := sqlx.NewDb(s.db.(*sql.DB), "mysql")
	s.log.Trace().Str("fn", "Store.QueryInto").Str("stmt", s.stmt.String()).Interface("args", args).Msg("sql")
	return dbx.Get(dest, s.stmt.Query(), args...)
}

// Columns to be used for various statements.
func (s *Store) Columns(cols ...int) *Store {
	if s.stmt != nil && !s.selectCalled {
		s.stmt.Append("SELECT")
	}
	if s.colSet == nil {
		s.colSet = big.NewInt(0)
	}
	for _, col := range cols {
		s.colSet.SetBit(s.colSet, col, 1)
	}
	return s
}

func (s *Store) Fields(prefix string, fieldFunc func(*big.Int) []string) *Store {
	s.stmt.Fields(s.prependField, prefix, fieldFunc(s.colSet))
	s.prependField = ","
	return s
}

// queryBegin is a helper for other querying funcs.
func (s *Store) queryBegin(stmt string, args ...interface{}) (*sql.Rows, []sql.RawBytes, []interface{}, error) {
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "queryBegin").Str("stmt", stmt).Interface("args", args).Msg("sql")
	}
	rows, err := s.db.Query(stmt, args...)
	if err != nil {
		s.log.Error().Err(err).Msg("query")
		return nil, nil, nil, err
	}
	colNames, err := rows.Columns()
	if err != nil {
		s.log.Error().Err(err).Msg("colNames")
		return nil, nil, nil, err
	}
	columnValues := make([]sql.RawBytes, len(colNames))
	columnPointers := make([]interface{}, len(colNames))
	for i := range columnValues {
		columnPointers[i] = &columnValues[i]
	}
	return rows, columnValues, columnPointers, err
}

// one is a helper for other stores' One's funcs.
func (s *Store) one(data Bindable, stmt *sdb.SQLStatement, args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			s.log.Error().Err(err).Msg("scan")
			return err
		}
		col := 0
		data.bind(values, s.withJoin, s.colSet, &col)
	} else {
		return sql.ErrNoRows
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

// MapScan gets a single row from a custom query.
func (s *Store) MapScan(dest map[string]sql.RawBytes, args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			s.log.Error().Err(err).Msg("scan")
			return err
		}

		var columns []string
		columns, err = rows.Columns()
		if err != nil {
			s.log.Error().Err(err).Msg("columns")
			return err
		}

		for i, column := range columns {
			dest[column] = values[i]
		}
	} else {
		return sql.ErrNoRows
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

// OneValue retrieves a single column from the first row as generic interface{}.
// Specify the bindFunc to map the DB return value to the correct type.
func (s *Store) OneValue(bindFunc func([]byte) interface{}, args ...interface{}) (interface{}, error) {
	s.log.Trace().Str("fn", "Store.OneValue").Str("stmt", s.stmt.String()).Interface("args", args).Msg("sql")
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return false, err
	}
	defer rows.Close()

	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			s.log.Error().Err(err).Msg("scan")
			return false, err
		}
		return bindFunc(values[0]), nil
	}
	return false, sql.ErrNoRows
}

// OneString retrieves a single column from the first row as string.
func (s *Store) OneString(args ...interface{}) (string, error) {
	v, err := s.OneValue(func(b []byte) interface{} {
		return sdb.ToString(b)
	}, args...)
	if err != nil {
		return "", err
	}
	return v.(string), err
}

// OneInt retrieves a single column from the first row as int.
func (s *Store) OneInt(args ...interface{}) (int, error) {
	v, err := s.OneValue(func(b []byte) interface{} {
		return sdb.ToInt(b)
	}, args...)
	if err != nil {
		return 0, err
	}
	return v.(int), err
}

// OneBool retrieves a single column from the first row as bool.
func (s *Store) OneBool(args ...interface{}) (bool, error) {
	v, err := s.OneValue(func(b []byte) interface{} {
		return sdb.ToBool(b)
	}, args...)
	if err == sql.ErrNoRows {
		return false, nil
	}
	return v.(bool), err
}

// QueryCustom retrieves many rows from 'best.bestellung' as a slice of Bestellung with possible joined data.
func (s *Store) queryCustom(res []Bindable, d Bindable, stmt string, args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(stmt, args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	col := 0
	for rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			s.log.Error().Err(err).Msg("scan")
			return err
		}
		data := d.new()
		col = 0
		data.bind(values, s.withJoin, s.colSet, &col)
		res = append(res, data)
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

func (s *Store) SelectFields(tableAlias string, fieldFunc func(*big.Int) []string, columns ...int) *Store {
	if len(columns) > 0 {
		if s.colSet == nil {
			s.colSet = big.NewInt(0)
		}

		for _, col := range columns {
			s.colSet.SetBit(s.colSet, col, 1)
		}
	}

	if !s.selectCalled {
		s.stmt.AppendStr("SELECT ")
		s.selectCalled = true
	}

	s.stmt.Fields(s.prependField, tableAlias, fieldFunc(s.colSet))
	s.prependField = ", "

	s.stmt.AppendStr(" ")

	return s
}

func (s *Store) rowToSlice(dest interface{}, values []sql.RawBytes, col *int) error {
	value := reflect.ValueOf(dest)

	if value.Kind() != reflect.Ptr {
		panic("must pass a pointer, not a value, to StructScan destination")
	}
	if value.IsNil() {
		panic("nil pointer passed to StructScan destination")
	}
	var direct reflect.Value
	if value.Kind() == reflect.Struct {
		tempSlicePtrValue := reflect.New(reflect.SliceOf(value.Type()))
		tempSliceValue := tempSlicePtrValue.Elem()
		direct = reflect.Indirect(tempSliceValue)
	} else {
		direct = reflect.Indirect(value)
	}

	if direct.Kind() != reflect.Slice {
		panic("must pass a pointer to a slice")
	}

	slice, err := baseType(value.Type(), reflect.Slice)
	if err != nil {
		return err
	}

	base := reflectx.Deref(slice.Elem())
	vp := reflect.New(base)
	v := reflect.Indirect(vp)

	s.mapRowToStruct(v, values, col)

	direct.Set(reflect.Append(direct, v))

	// spew.Dump("final", dest)

	return nil
}

func (s *Store) mapRowToStruct(pStruct reflect.Value, values []sql.RawBytes, col *int) error {
	baseType := pStruct.Type()

	for i := 0; i < pStruct.NumField(); i++ {
		field := pStruct.Field(i)

		switch field.Kind() {
		case reflect.Struct:
			fType := baseType.Field(i)
			if fType.Anonymous {
				data := field.Interface().(Bindable)
				data.bind(values, false, s.colSet, col)
			} else {
				s.mapRowToStruct(field, values, col)
			}
		case reflect.Slice:

		default:
			return errors.New("only structs and slices allowed")
		}
	}
	return nil
}

func (s *Store) QueryBind(dest interface{}, args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	col := 0
	for rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			s.log.Error().Err(err).Msg("scan")
			return err
		}
		col = 0
		err = s.rowToSlice(dest, values, &col)
		if err != nil {
			s.log.Error().Err(err).Msg("scan")
			return err
		}
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

func (s *Store) OneBind(dest interface{}, args ...interface{}) error {
	value := reflect.ValueOf(dest)
	if value.Kind() != reflect.Ptr {
		panic("must pass a pointer, not a value, to StructScan destination")
	}
	if value.IsNil() {
		panic("nil pointer passed to StructScan destination")
	}
	direct := reflect.Indirect(value)

	s.log.Trace().Str("fn", "Store.OneBind").Str("stmt", s.stmt.String()).Interface("args", args).Msg("sql")
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	col := 0
	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			s.log.Error().Err(err).Msg("scan")
			return err
		}
		col = 0
		err = s.mapRowToStruct(direct, values, &col)
		if err != nil {
			s.log.Error().Err(err).Msg("mapping")
			return err
		}
	} else {
		return sql.ErrNoRows
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

func baseType(t reflect.Type, expected reflect.Kind) (reflect.Type, error) {
	t = reflectx.Deref(t)
	if t.Kind() != expected {
		return nil, fmt.Errorf("expected %s but got %s", expected, t.Kind())
	}
	return t, nil
}

// ^^ END OF GENERATED BY CODEGEN. ^^
