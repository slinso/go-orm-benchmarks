package {{ .Conf.Package }}


import (
	"testing"

	{{ .Conf.RootPackage }} "{{ .Conf.RootPackageInclude }}"
	
	"github.com/seambiz/seambiz/stime"
	"github.com/seambiz/seambiz/sdb"
	"github.com/DATA-DOG/go-sqlmock"
)

// GENERATED BY CODEGEN. 

{{- $conf := .Conf -}}
{{- $table := .Table -}}
{{- $schema := .Schema }}

// Insert inserts the {{ $table.Title }} to the database.
func Test{{ $table.Title }}Insert(t *testing.T) {
	ctx := &{{ $conf.RootPackage }}.Context{Log:&zerolog.Logger{}}
   	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	{{- if $schema.IsMultiTenant }}
	mock.
		ExpectExec("INSERT INTO " + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $table.Name }} (
	{{- else }}
	mock.
		ExpectExec("INSERT INTO {{ $schema.Name }}.{{ $table.Name }} (
	{{- end }}
	{{- range $i, $field := $table.Fields }}
    {{- if gt $i 0 }}, {{ end -}}
    {{ lower $field.Name }}
    {{- end -}}
	) VALUES ({{` `}}
	{{- range $i, $field := $table.Fields }}
    {{- if gt $i 0 }} , {{ end -}}
    ?
    {{- end -}}{{` `}})").
		WithArgs(
			{{- range $i, $field := $table.Fields }}
    		{{- if gt $i 0 }}, {{ end -}}
    		{{ if $field.IsNullable }}nil{{ else }}{{ if has (lower $field.Name) (list "created_at" "updated_at") }}TimeSec5{}{{ else }}{{ $field.GoZero }}{{ end }}{{ end }}
    		{{- end -}}
		).
		WillReturnResult(sqlmock.NewResult(1, 1))


	{{- if $schema.IsMultiTenant }}
	store := New{{ $table.Title }}Store(0, db)
	{{- else }}
	store := New{{ $table.Title }}Store(ctx, db)
	{{- end }}
	err = store.Insert(&{{ .Conf.RootPackage }}.{{  $table.Title }}{})
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

func Test{{ $table.Title }}Update(t *testing.T) {
	ctx := &{{ $conf.RootPackage }}.Context{Log:&zerolog.Logger{}}
   	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	{{- if $schema.IsMultiTenant }}
	mock.
		ExpectExec("UPDATE "  + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $table.Name }}
	{{- else }}
	mock.
		ExpectExec("UPDATE {{ $schema.Name }}.{{ $table.Name }}
	{{- end -}}
	{{` SET `}}
	{{- range $i, $field := $table.OtherFields }}
    {{- if gt $i 0 }},{{ end -}}
    {{ lower $field.Name }} = ?
    {{- end -}}
	{{` WHERE `}}{{ range $i, $f := $table.PkFields -}}
		{{- if gt $i 0 }} AND {{ end }}{{ $f.Name }} = ?
	{{- end -}}").
		WithArgs(
			{{- range $i, $field := $table.OtherFields }}
    		{{- if gt $i 0 }}, {{ end -}}
    		{{ if $field.IsNullable }}nil{{ else }}{{ if has (lower $field.Name) (list "updated_at") }}TimeSec5{}{{ else }}{{ $field.GoZero }}{{ end }}{{ end }}
    		{{- end -}}
			{{- range $i, $field := $table.PkFields -}}
    		, {{ if $field.IsNullable }}nil{{ else }}{{ $field.GoZero }}{{ end }}
    		{{- end -}}
		).
		WillReturnResult(sqlmock.NewResult(0, 1))

	{{- if $schema.IsMultiTenant }}
	store := New{{ $table.Title }}Store(0, db)
	{{- else }}
	store := New{{ $table.Title }}Store(ctx, db)
	{{- end }}
	aff, err := store.Update(&{{ .Conf.RootPackage }}.{{  $table.Title }}{})
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	if aff != 1 {
		t.Errorf("a single row should be affected: %d", aff)
	}
}

func Test{{ $table.Title }}SelectWithoutJoin(t *testing.T) {
	ctx := &{{ $conf.RootPackage }}.Context{Log:&zerolog.Logger{}}
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()
	rows := sqlmock.NewRows([]string{
	{{- /* base table */}}
	{{- range $i, $field := $table.Fields -}}
    {{- if gt $i 0 }}, {{ end -}}
    "A.{{ lower $field.Name }}"
    {{- end -}}
	}).
	{{- $myList := list 1 2 }}{{ range $list := $myList }}
	AddRow(
		{{- /* base table */}}
		{{- range $i, $field := $table.Fields -}}
		{{- if gt $i 0 }}, {{ end -}}
		{{ if $field.IsNullable }}nil{{ else }}{{ $field.GoZero }}{{ end }}
		{{- end -}}
		){{ if eq $list 1}}.{{ end }}
	{{- end }}

	mock.ExpectQuery("SELECT{{` `}}
	{{- /* base table */}}
	{{- range $i, $field := $table.Fields -}}
    {{- if gt $i 0 }}, {{ end -}}
    A.{{ lower $field.Name }}
    {{- end -}}
	
	{{` FROM `}}
	
	{{- if $schema.IsMultiTenant -}}
		" + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $table.Name }} A
	{{- else -}}
		{{ $schema.Name }}.{{ $table.Name }} A
	{{- end -}}
	").
		WillReturnRows(rows)

	{{- if $schema.IsMultiTenant }}
	store := New{{ $table.Title }}Store(0, db)
	{{- else }}
	store := New{{ $table.Title }}Store(ctx, db)
	{{- end -}}
	.WithoutJoins()
	data, err := store.Query()
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}

	if len(data) != 2 {
		t.Errorf("number of rows != 2: %d", len(data))
	}
}	

{{ if gt $table.NumUniqueFKs 0 }}
func Test{{ $table.Title }}SelectJoin(t *testing.T) {
	ctx := &{{ $conf.RootPackage }}.Context{Log:&zerolog.Logger{}}
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()
	rows := sqlmock.NewRows([]string{
	{{- /* base table */}}
	{{- range $i, $field := $table.Fields -}}
    {{- if gt $i 0 }}, {{ end -}}
    "A.{{ lower $field.Name }}"
    {{- end -}}
	
	{{/* joined tables */}}
	{{- range $join := $table.Joins }}
		{{- range $i, $field := $join.Table.Fields -}}
			, "{{ $join.Alias }}.{{ lower $field.Name }}"
		{{- end -}}
	{{- end -}}
	}).
	{{- $myList := list 1 2 }}{{ range $list := $myList }}
	AddRow(
		{{- /* base table */}}
		{{- range $i, $field := $table.Fields -}}
		{{- if gt $i 0 }}, {{ end -}}
		{{ if $field.IsNullable }}nil{{ else }}{{ $field.GoZero }}{{ end }}
		{{- end -}}
		{{/* joined tables */}}
		{{- range $join := $table.Joins }}
			{{- range $i, $field := $join.Table.Fields -}}
				, {{ if $field.IsNullable }}nil{{ else }}{{ if $field.IsAutoincrement }}1{{ else }}{{ $field.GoZero }}{{ end }}{{ end }}
			{{- end -}}
		{{- end -}}
		){{ if eq $list 1}}.{{ end }}
	{{- end }}

	mock.ExpectQuery("SELECT{{` `}}
	{{- /* base table */}}
	{{- range $i, $field := $table.Fields -}}
    {{- if gt $i 0 }}, {{ end -}}
    A.{{ lower $field.Name }}
    {{- end -}}
	
	{{/* joined tables */}}
	{{- range $join := $table.Joins }}
		{{- range $i, $field := $join.Table.Fields -}}
			, {{ $join.Alias }}.{{ lower $field.Name }}
		{{- end -}}
	{{- end -}}

	{{` FROM `}}
	
	{{- if $schema.IsMultiTenant -}}
		" + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $table.Name }} A
	{{- else -}}
		{{ $schema.Name }}.{{ $table.Name }} A
	{{- end -}}

	{{- range $join := $table.Joins }}
		{{- if $schema.IsMultiTenant -}}
			{{` `}}LEFT JOIN " + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $join.Name }} {{ $join.Alias }} ON (
		{{- else -}}
			{{` `}}LEFT JOIN {{ $join.Schema }}.{{ $join.Name }} {{ $join.Alias }} ON (
		{{- end -}}
		{{- range $i, $fk := $join.Fields -}}
			{{- if gt $i 0 }} AND {{ end -}} 
			{{ $fk.Alias }}.{{ $fk.Name}} = {{ $fk.RefAlias }}.{{ $fk.RefName }}
		{{- end -}}
		)
	{{- end -}}
	").
		WillReturnRows(rows)

	{{- if $schema.IsMultiTenant }}
	store := New{{ $table.Title }}Store(0, db)
	{{- else }}
	store := New{{ $table.Title }}Store(ctx, db)
	{{- end }}
	data, err := store.Query()
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}

	if len(data) != 2 {
		t.Errorf("number of rows != 2: %d", len(data))
	}
	{{/* joined tables */}}
	{{ range $fk := .Table.ForeignKeys }}
		{{ if $fk.IsUnique }}
			if data[0].{{ $fk.CustomName }} == nil {
				t.Errorf("join did not work: %v", data[0].{{ $fk.CustomName }})
			}
		{{- end -}}
	{{- end -}}
}	
{{ end }}

{{ if not $schema.IsMultiTenant }}
	{{ range $fk := .Table.ForeignKeys }}
		{{ if not $fk.IsUnique }}
func Test{{ $table.Title }}{{ $fk.CustomName }}EagerFetch(t *testing.T) {
	ctx := &{{ $conf.RootPackage }}.Context{Log:&zerolog.Logger{}}
   	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	{{/* base query */}}
	rows := sqlmock.NewRows([]string{
	{{- /* base table */}}
	{{- range $i, $field := $table.Fields -}}
    {{- if gt $i 0 }}, {{ end -}}
    "A.{{ lower $field.Name }}"
    {{- end -}}
	}).
	AddRow(
		{{- /* base table */}}
		{{- range $i, $field := $table.Fields -}}
		{{- if gt $i 0 }}, {{ end -}}
		{{ if $field.IsNullable }}nil{{ else }}{{ $field.GoZero }}{{ end }}
		{{- end -}}
		{{/* joined tables */}}
		{{- range $join := $table.Joins }}
			{{- range $i, $field := $join.Table.Fields -}}
				, {{ if $field.IsNullable }}nil{{ else }}{{ if $field.IsAutoincrement }}1{{ else }}{{ $field.GoZero }}{{ end }}{{ end }}
			{{- end -}}
		{{- end -}}
		)
	mock.ExpectQuery("SELECT{{` `}}
	{{- /* base table */}}
	{{- range $i, $field := $table.Fields -}}
    {{- if gt $i 0 }}, {{ end -}}
    A.{{ lower $field.Name }}
    {{- end -}}

	{{` FROM `}}
	
	{{- if $schema.IsMultiTenant -}}
		" + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $table.Name }} A
	{{- else -}}
		{{ $schema.Name }}.{{ $table.Name }} A
	{{- end -}}
	").
		WillReturnRows(rows)

	{{/* eager fetch query */}}
	rows = sqlmock.NewRows([]string{
	{{- /* base table */}}
	{{- range $i, $field := $fk.GenTable.Fields -}}
    {{- if gt $i 0 }}, {{ end -}}
    "A.{{ lower $field.Name }}"
    {{- end -}}
	
	{{/* joined tables */}}
	{{- range $join := $fk.GenTable.Joins }}
		{{- range $i, $field := $join.Table.Fields -}}
			, "{{ $join.Alias }}.{{ lower $field.Name }}"
		{{- end -}}
	{{- end -}}
	}).
	{{- $myList := list 1 2 }}{{ range $list := $myList }}
	AddRow(
		{{- /* base table */}}
		{{- range $i, $field := $fk.GenTable.Fields -}}
		{{- if gt $i 0 }}, {{ end -}}
		{{ if $field.IsNullable }}nil{{ else }}{{ if $field.IsAutoincrement }}{{ $list }}{{ else }}{{ $field.GoZero }}{{ end }}{{ end }}
		{{- end -}}
		{{/* joined tables */}}
		{{- range $join := $fk.GenTable.Joins }}
			{{- range $i, $field := $join.Table.Fields -}}
				, {{ if $field.IsNullable }}nil{{ else }}{{ if $field.IsAutoincrement }}0{{ else }}{{ $field.GoZero }}{{ end }}{{ end }}
			{{- end -}}
		{{- end -}}
		){{ if eq $list 1}}.{{ end }}
	{{- end }}

	mock.ExpectQuery("SELECT{{` `}}
	{{- /* base table */}}
	{{- range $i, $field := $fk.GenTable.Fields -}}
    {{- if gt $i 0 }}, {{ end -}}
    A.{{ lower $field.Name }}
    {{- end -}}
	
	{{/* joined tables */}}
	{{- range $join := $fk.GenTable.Joins }}
		{{- range $i, $field := $join.Table.Fields -}}
			, {{ $join.Alias }}.{{ lower $field.Name }}
		{{- end -}}
	{{- end -}}

	{{` FROM `}}
	
	{{- if $schema.IsMultiTenant -}}
		" + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $fk.GenTable.name }} A
	{{- else -}}
		{{ $schema.Name }}.{{ $fk.GenTable.Name }} A
	{{- end -}}

	{{- range $join := $fk.GenTable.Joins }}
		{{- if $schema.IsMultiTenant -}}
			{{` `}}LEFT JOIN " + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $join.Name }} {{ $join.Alias }} ON (
		{{- else -}}
			{{` `}}LEFT JOIN {{ $join.Schema }}.{{ $join.Name }} {{ $join.Alias }} ON (
		{{- end -}}
		{{- range $i, $fk := $join.Fields -}}
			{{- if gt $i 0 }} AND {{ end -}} 
			{{ $fk.Alias }}.{{ $fk.Name}} = {{ $fk.RefAlias }}.{{ $fk.RefName }}
		{{- end -}}
		)
	{{- end -}}
	{{` WHERE `}}{{ index $fk.RefFields 0 }} IN (0) ORDER BY A.{{ index $fk.RefFields 0 }} DESC, A.{{ index $fk.Fields 0 }} DESC").
		WillReturnRows(rows)

	{{- if $schema.IsMultiTenant }}
	store := New{{ $table.Title }}Store(0, db)
	{{- else }}
	store := New{{ $table.Title }}Store(ctx, db)
	{{- end }}
	data, err := store.Query()
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}
	err = store.EagerFetch{{ $fk.CustomName }}(data)
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}

	if len(data) != 1 {
		t.Errorf("number of base rows != 1: %d", len(data))
	}

	if len(data[0].{{ $fk.CustomName }}) != 2 {
		t.Errorf("should have 2 associated rows: %v", data)
	}
}
		{{- end }}
	{{- end }}
{{- end }}

{{- if gt (len $table.PkFields) 0 }}
func Test{{ $table.Title }}Delete(t *testing.T) {
	ctx := &{{ $conf.RootPackage }}.Context{Log:&zerolog.Logger{}}
   	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	{{- if $schema.IsMultiTenant }}
	mock.
		ExpectExec("DELETE FROM " + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $table.Name }}
	{{- else }}
	mock.
		ExpectExec("DELETE FROM {{ $schema.Name }}.{{ $table.Name }}
	{{- end -}}
	{{` WHERE `}}{{ range $i, $f := $table.PkFields -}}
		{{- if gt $i 0 }} AND {{ end }}{{ $f.Name }} = ?
	{{- end -}}").
		WithArgs(
			{{- range $i, $field := $table.PkFields -}}
    		{{- if gt $i 0 }}, {{ end -}}
			{{ if $field.IsNullable }}nil{{ else }}{{ $field.GoZero }}{{ end }}
    		{{- end -}}
		).
		WillReturnResult(sqlmock.NewResult(0, 1))


	{{- if $schema.IsMultiTenant }}
	aff, err := New{{ $table.Title }}Store(0, db).Delete(&{{ .Conf.RootPackage }}.{{  $table.Title }}{})
	{{- else }}
	aff, err := New{{ $table.Title }}Store(ctx, db).Delete(&{{ .Conf.RootPackage }}.{{  $table.Title }}{})
	{{- end }}
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	if aff != 1 {
		t.Errorf("a single row should be affected: %d", aff)
	}
}


{{- $tmp := (index $table.PkFields 0) -}}
{{ if and (eq (len $table.PkFields) 1) (eq $tmp.GoType "int") }}
func Test{{ $table.Title }}DeleteSlice(t *testing.T) {
	ctx := &{{ $conf.RootPackage }}.Context{Log:&zerolog.Logger{}}
   	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	{{- if $schema.IsMultiTenant }}
	mock.
		ExpectExec("DELETE FROM " + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $table.Name }}
	{{- else }}
	mock.
		ExpectExec("DELETE FROM {{ $schema.Name }}.{{ $table.Name }}
	{{- end -}}
	{{- $tmp := (index $table.PkFields 0) -}}
	{{` WHERE `}}{{ $tmp.Name }} IN (0,0)").
		WillReturnResult(sqlmock.NewResult(0, 2))



	{{- if $schema.IsMultiTenant }}
	aff, err := New{{ $table.Title }}Store(0, db).DeleteSlice([]*{{ .Conf.RootPackage }}.{{  $table.Title }}{{`{{},{}}`}})
		{{- else }}
	aff, err := New{{ $table.Title }}Store(ctx, db).DeleteSlice([]*{{ .Conf.RootPackage }}.{{  $table.Title }}{{`{{},{}}`}})
	{{- end }}
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	if aff != 2 {
		t.Errorf("two rows should be affected: %d", aff)
	}
}
{{ end }}
{{ end }}

{{/**************************************************************************
Upsert will come back later
Upsert only avaible if table has a PK
{{- if gt (len $table.PkFields) 0 }}
func Test{{ $table.Title }}Upsert(t *testing.T) {
   	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	{{- if $schema.IsMultiTenant }}
	mock.
		ExpectExec("INSERT INTO " + fmt.Sprintf("{{ $schema.MTSchemaFmt }}", 0) + ".{{ $table.Name }} (
	{{- else }}
	mock.
		ExpectExec("INSERT INTO {{ $schema.Name }}.{{ $table.Name }} (
	{{- end }}{{` `}}
	{{- range $i, $field := $table.Fields }}
    {{- if gt $i 0 }}, {{ end -}}
    `{{ lower $field.Name }}`{{` `}}
    {{- end -}}
	) VALUES{{` `}}
	
	{{- $myList := list 1 2 }}{{ range $i, $list := $myList }}
	{{- if gt $i 0 }}, {{ end -}}
	(
		{{- range $i, $field := $table.Fields -}}
		{{- if gt $i 0 }},{{ end -}}
		{{` `}}{{ if $field.IsNullable }}NULL{{ else }}'{{ if not (has $field.GoZero (list "[]byte(nil)" "[]")) }}{{ $field.GoZero | replace "\"" "" }}{{ end }}'{{ end }}{{` `}}
		{{- end -}}
	)
	{{- end -}}

	{{- $tmp := (index $table.PkFields 0) -}}
	{{` ON DUPLICATE KEY UPDATE `}}
	{{- range $i, $field := $table.OtherFields }}
    {{- if gt $i 0 }},{{ end -}}
    {{ lower $field.Name }} = VALUES({{ lower $field.Name }})
    {{- end -}}	
	").
		WillReturnResult(sqlmock.NewResult(0, 2))


	{{- if $schema.IsMultiTenant }}
	aff, err := New{{ $table.Title }}Store(0, db).Upsert([]*{{ .Conf.RootPackage }}.{{  $table.Title }}{{`{{},{}}`}}...)
	{{- else }}
	aff, err := New{{ $table.Title }}Store(db).Upsert([]*{{ .Conf.RootPackage }}.{{  $table.Title }}{{`{{},{}}`}}...)
	{{- end }}
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	if aff != 2 {
		t.Errorf("two rows should be affected: %d", aff)
	}
}
{{ end }}
**************************************************************************/}}

// ^^ END OF GENERATED BY CODEGEN. ^^
