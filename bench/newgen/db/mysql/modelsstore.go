package mysql

import (
	"database/sql"
	"errors"
	"io"
	"math/big"

	"github.com/efectn/go-orm-benchmarks/bench/newgen"
	"github.com/seambiz/seambiz/sdb"
)

// GENERATED BY newgen.

// Models represents a row from 'models'.
type Models struct {
	ID      int    `json:"ID" db:"id"`
	Name    string `json:"NAME" db:"name"`
	Title   string `json:"title" db:"title"`
	Fax     string `json:"fax" db:"fax"`
	Web     string `json:"web" db:"web"`
	Age     int    `json:"age" db:"age"`
	Right   bool   `json:"right" db:"right"`
	Counter int64  `json:"counter" db:"counter"`
}

// new implements Bindable.new
func (s *Models) new() Bindable {
	return new(Models)
}

func (s *Models) Pointers() []interface{} {
	return []interface{}{
		&s.ID,
		&s.Name,
		&s.Title,
		&s.Fax,
		&s.Web,
		&s.Age,
		&s.Right,
		&s.Counter,
	}
}

// helper struct for common query operations.
type ModelsSlice struct {
	data []*Models
}

// append implements BindableSlice.append
func (s *ModelsSlice) append(d Bindable) {
	s.data = append(s.data, d.(*Models))
}

// constant slice for all fields of the table "Models".
// nolint[gochecknoglobals]
var modelsQueryFieldsAll = []string{"id", "name", "title", "fax", "web", "age", "\"right\"", "counter"}

// returns fields, that should be used.
// nolint[gocyclo]
func ModelsQueryFields(colSet *big.Int) []string {
	if colSet == nil {
		return modelsQueryFieldsAll
	}

	fields := []string{}
	if colSet.Bit(newgen.Models_ID) == 1 {
		fields = append(fields, "id")
	}

	if colSet.Bit(newgen.Models_Name) == 1 {
		fields = append(fields, "name")
	}

	if colSet.Bit(newgen.Models_Title) == 1 {
		fields = append(fields, "title")
	}

	if colSet.Bit(newgen.Models_Fax) == 1 {
		fields = append(fields, "fax")
	}

	if colSet.Bit(newgen.Models_Web) == 1 {
		fields = append(fields, "web")
	}

	if colSet.Bit(newgen.Models_Age) == 1 {
		fields = append(fields, "age")
	}

	if colSet.Bit(newgen.Models_Right) == 1 {
		fields = append(fields, "\"right\"")
	}

	if colSet.Bit(newgen.Models_Counter) == 1 {
		fields = append(fields, "counter")
	}
	return fields
}

// ModelsStore is used to query for 'Models' records.
type ModelsStore struct {
	Store
	ctx *newgen.Context
}

// NewModelsStore return DAO Store for Models
func NewModelsStore(ctx *newgen.Context, conn Execer) *ModelsStore {
	s := &ModelsStore{}
	s.db = conn
	s.withJoin = true
	s.joinType = sdb.LEFT
	s.batch = 1000
	s.log = ctx.Log
	s.ctx = ctx
	return s
}

// WithoutJoins won't execute JOIN when querying for records.
func (s *ModelsStore) WithoutJoins() *ModelsStore {
	s.withJoin = false
	return s
}

// Where sets local sql, that will be appended to SELECT.
func (s *ModelsStore) Where(sql string) *ModelsStore {
	s.where = sql
	return s
}

// OrderBy sets local sql, that will be appended to SELECT.
func (s *ModelsStore) OrderBy(sql string) *ModelsStore {
	s.orderBy = sql
	return s
}

// GroupBy sets local sql, that will be appended to SELECT.
func (s *ModelsStore) GroupBy(sql string) *ModelsStore {
	s.groupBy = sql
	return s
}

// Limit result set size
func (s *ModelsStore) Limit(n int) *ModelsStore {
	s.limit = n
	return s
}

// Offset used, if a limit is provided
func (s *ModelsStore) Offset(n int) *ModelsStore {
	s.offset = n
	return s
}

// JoinType sets join statement type (Default: INNER | LEFT | RIGHT | OUTER).
func (s *ModelsStore) JoinType(jt string) *ModelsStore {
	s.joinType = jt
	return s
}

// Columns sets bits for specific columns.
func (s *ModelsStore) Columns(cols ...int) *ModelsStore {
	s.Store.Columns(cols...)
	return s
}

// SetBits sets complete BitSet for use in UpdatePartial.
func (s *ModelsStore) SetBits(colSet *big.Int) *ModelsStore {
	s.colSet = colSet
	return s
}

func (s *Models) bind(row []sql.RawBytes, withJoin bool, colSet *big.Int, col *int) {
	if colSet == nil || colSet.Bit(newgen.Models_ID) == 1 {
		s.ID = sdb.ToInt(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(newgen.Models_Name) == 1 {
		s.Name = sdb.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(newgen.Models_Title) == 1 {
		s.Title = sdb.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(newgen.Models_Fax) == 1 {
		s.Fax = sdb.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(newgen.Models_Web) == 1 {
		s.Web = sdb.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(newgen.Models_Age) == 1 {
		s.Age = sdb.ToInt(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(newgen.Models_Right) == 1 {
		b := sdb.ToUnsafeString(row[*col])
		s.Right = b[0] == 't'

		*col++
	}
	if colSet == nil || colSet.Bit(newgen.Models_Counter) == 1 {
		s.Counter = sdb.ToInt64(row[*col])
		*col++
	}
}

func (s *ModelsStore) selectStatement() *sdb.SQLStatement {
	sql := sdb.NewSQLStatement()
	sql.Append("SELECT")
	sql.Fields("", "A", ModelsQueryFields(s.colSet))
	sql.Append(" FROM models A ")
	if s.where != "" {
		sql.Append("WHERE", s.where)
	}
	if s.groupBy != "" {
		sql.Append("GROUP BY", s.groupBy)
	}
	if s.orderBy != "" {
		sql.Append("ORDER BY", s.orderBy)
	}
	if s.limit > 0 {
		sql.AppendRaw("LIMIT ", s.limit)
		if s.offset > 0 {
			sql.AppendRaw(",", s.offset)
		}
	}
	return sql
}

// QueryCustom retrieves many rows from 'models' as a slice of Models with 1:1 joined data.
func (s *ModelsStore) QueryCustom(stmt string, args ...interface{}) ([]*Models, error) {
	dto := &Models{}
	data := &ModelsSlice{}
	err := s.queryCustom(data, dto, stmt, args...)
	if err != nil {
		s.log.Error().Err(err).Msg("querycustom")
		return nil, err
	}

	return data.data, nil
}

// Query retrieves many rows from 'models' as a slice of Models with 1:1 joined data.
func (s *ModelsStore) Query(args ...interface{}) ([]*Models, error) {
	stmt := s.selectStatement()
	return s.QueryCustom(stmt.Query(), args...)
}

// modelsUpsertStmt helper for generating Upsert statement.
// nolint:gocyclo
func (s *ModelsStore) modelsUpsertStmt() *sdb.UpsertStatement {
	upsert := []string{}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Name) == 1 {
		upsert = append(upsert, "name = VALUES(name)")
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Title) == 1 {
		upsert = append(upsert, "title = VALUES(title)")
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Fax) == 1 {
		upsert = append(upsert, "fax = VALUES(fax)")
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Web) == 1 {
		upsert = append(upsert, "web = VALUES(web)")
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Age) == 1 {
		upsert = append(upsert, "age = VALUES(age)")
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Right) == 1 {
		upsert = append(upsert, "\"right\" = VALUES(right)")
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Counter) == 1 {
		upsert = append(upsert, "counter = VALUES(counter)")
	}
	sql := &sdb.UpsertStatement{}
	sql.InsertInto("models")
	sql.Columns("id", "name", "title", "fax", "web", "age", "\"right\"", "counter")
	sql.OnDuplicateKeyUpdate(upsert)
	return sql
}

// Upsert executes upsert for array of Models
func (s *ModelsStore) Upsert(data ...*newgen.Models) (int64, error) {
	sql := s.modelsUpsertStmt()

	for _, d := range data {
		sql.Record(d)
	}

	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "ModelsUpsert").Str("stmt", sql.String()).Msg("sql")
	}
	res, err := s.db.Exec(sql.Query())
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return -1, err
	}
	affected, err := res.RowsAffected()
	if err != nil {
		s.log.Error().Err(err).Msg("rowsaffected")
		return -1, err
	}

	return affected, nil
}

// Insert inserts the Models to the database.
func (s *ModelsStore) Insert(data *newgen.Models) error {
	var err error
	sql := sdb.NewSQLStatement()
	sql.AppendRaw("INSERT INTO models (")
	fields := ModelsQueryFields(s.colSet)
	fields = fields[1:]
	sql.Fields("", "", fields)
	sql.Append(") VALUES (")
	for i := range fields {
		if i > 0 {
			sql.Append(",")
		}
		sql.AppendRaw("$", i+1)
	}
	sql.Append(")")

	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "models.Insert").Str("stmt", sql.String()).Int("ID", data.ID).Str("Name", data.Name).Str("Title", data.Title).Str("Fax", data.Fax).Str("Web", data.Web).Int("Age", data.Age).Bool("Right", data.Right).Int64("Counter", data.Counter).Msg("sql")
	}
	_, err = s.db.Exec(sql.Query(), data.Name, data.Title, data.Fax, data.Web, data.Age, data.Right, data.Counter)
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return err
	}

	return nil
}

// Update updates the Models in the database.
// nolint[gocyclo]
func (s *ModelsStore) Update(data *newgen.Models) (int64, error) {
	sql := sdb.NewSQLStatement()
	var prepend string
	args := []interface{}{}
	sql.Append("UPDATE models SET")
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Name) == 1 {
		sql.AppendRaw(prepend, "name = ?")
		prepend = ","
		args = append(args, data.Name)
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Title) == 1 {
		sql.AppendRaw(prepend, "title = ?")
		prepend = ","
		args = append(args, data.Title)
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Fax) == 1 {
		sql.AppendRaw(prepend, "fax = ?")
		prepend = ","
		args = append(args, data.Fax)
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Web) == 1 {
		sql.AppendRaw(prepend, "web = ?")
		prepend = ","
		args = append(args, data.Web)
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Age) == 1 {
		sql.AppendRaw(prepend, "age = ?")
		prepend = ","
		args = append(args, data.Age)
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Right) == 1 {
		sql.AppendRaw(prepend, "right = ?")
		prepend = ","
		args = append(args, data.Right)
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Counter) == 1 {
		sql.AppendRaw(prepend, "counter = ?")
		args = append(args, data.Counter)
	}
	sql.Append(" WHERE ID = ?")
	args = append(args, data.ID)
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "models.Update").Str("stmt", sql.String()).Interface("args", args).Msg("sql")
	}
	res, err := s.db.Exec(sql.Query(), args...)
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return 0, err
	}
	return res.RowsAffected()
}

// Delete deletes the Models from the database.
func (s *ModelsStore) Delete(data *newgen.Models) (int64, error) {
	var err error

	sql := sdb.NewSQLStatement()
	sql.Append("DELETE FROM models WHERE")
	sql.Append("ID = ?")

	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "models.Delete").Str("stmt", sql.String()).Int("ID", data.ID).Msg("sql")
	}
	res, err := s.db.Exec(sql.Query(), data.ID)
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return 0, err
	}
	return res.RowsAffected()
}

// DeleteSlice delets all slice element from the database.
func (s *ModelsStore) DeleteSlice(data []*newgen.Models) (int64, error) {
	var err error

	sql := sdb.NewSQLStatement()
	sql.Append("DELETE FROM models WHERE")
	sql.AppendRaw("ID IN (")
	for i := range data {
		if i > 0 {
			sql.AppendRaw(",")
		}
		sql.AppendInt(data[i].ID)
	}
	sql.Append(")")
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "models.DeleteSlice").Str("stmt", sql.String()).Msg("sql")
	}
	res, err := s.db.Exec(sql.Query())
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return 0, err
	}
	return res.RowsAffected()
}

// DeleteByQuery uses a where condition to delete entries.
func (s *ModelsStore) DeleteByQuery(args ...interface{}) (int64, error) {
	var err error
	sql := sdb.NewSQLStatement()
	sql.Append("DELETE FROM models")
	if s.where == "" {
		return 0, errors.New("no where condition set")
	}
	sql.Append("WHERE", s.where)
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "models.DeleteByQuery").Str("stmt", sql.String()).Interface("args", args).Msg("sql")
	}

	res, err := s.db.Exec(sql.Query(), args...)
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return 0, err
	}
	return res.RowsAffected()
}

// Truncate deletes all rows from Models.
func (s *ModelsStore) Truncate() error {
	sql := sdb.NewSQLStatement()
	sql.Append("TRUNCATE models")
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "models.Truncate").Str("stmt", sql.String()).Msg("sql")
	}
	_, err := s.db.Exec(sql.Query())
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
	}
	return err
}

// ToJSON writes a single object to the buffer.
// nolint[gocylco]
func (s *ModelsStore) ToJSON(t *sdb.JsonBuffer, data *Models) {
	prepend := "{"
	if s.colSet == nil || s.colSet.Bit(newgen.Models_ID) == 1 {
		t.JD(prepend, "id", data.ID)
		prepend = ","
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Name) == 1 {
		t.JS(prepend, "name", data.Name)
		prepend = ","
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Title) == 1 {
		t.JS(prepend, "title", data.Title)
		prepend = ","
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Fax) == 1 {
		t.JS(prepend, "fax", data.Fax)
		prepend = ","
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Web) == 1 {
		t.JS(prepend, "web", data.Web)
		prepend = ","
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Age) == 1 {
		t.JD(prepend, "age", data.Age)
		prepend = ","
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Right) == 1 {
		t.JB(prepend, "right", data.Right)
		prepend = ","
	}
	if s.colSet == nil || s.colSet.Bit(newgen.Models_Counter) == 1 {
		t.JD64(prepend, "counter", data.Counter)
	}
	t.S(`}`)
}

// ToJSONArray writes a slice to the named array.
func (s *ModelsStore) ToJSONArray(w io.Writer, data []*Models, name string) {
	t := sdb.NewJsonBuffer()
	t.SS(`{"`, name, `":[`)
	for i := range data {
		if i > 0 {
			t.S(",")
		}
		s.ToJSON(t, data[i])
	}

	t.S("]}")
	_, err := w.Write(t.Bytes())
	if err != nil {
		panic(err)
	}
}

// ^^ END OF GENERATED BY newgen. ^^
